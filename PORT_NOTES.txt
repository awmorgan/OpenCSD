================================================================================
OpenCSD Go Port - Developer Handoff Notes (2026-02-01)
================================================================================

PROJECT: Go port of ARM's CoreSight trace decoder library (OpenCSD).
Scope: ~22,400 lines of C++ → Go across 6 trace protocols + framework.

STATUS (2026-02-01):
  PTM protocol: ⚠️ PARTIAL (core decode works; only trace_cov_a15 has strict golden compare)
  ETMv4, ETMv3, ETE, STM, ITM: ⚠️ NOT STARTED
  Framework: PARTIAL (memory accessor, frame demux, printer done)

QUICK START:
  git clone https://github.com/awmorgan/OpenCSD && cd OpenCSD && git checkout go
  cd opencsd && go test ./ptm -v                      # Run PTM tests (coverage incomplete)
  go test ./ptm -v -run TestCompareAgainstPPL        # Full golden compare for trace_cov_a15 only

KEY LOCATIONS:
  Go code: opencsd/
  C++ reference: decoder/source/ and decoder/include/
  Test data: decoder/tests/snapshots/ (contains memory + device configs)
  Golden files: decoder/tests/results/*.ppl (authoritative reference)

GIT REPOSITORY & BRANCHES:
--------------------------
Repository: https://github.com/awmorgan/OpenCSD
Active Branch: go
Main C++ Code: main branch (decoder/ directory)
Go Port Location: go branch (opencsd/ directory)

Setup:
  git clone https://github.com/awmorgan/OpenCSD
  cd OpenCSD
  git checkout go

Go Module:
  module opencsd
  go 1.25.6
  No external dependencies (pure Go implementation)

VERIFICATION & TESTING:
-----------------------
Golden files (.ppl) are the authoritative reference. PTM is NOT complete until
all PTM-containing .ppl files are compared line-by-line against Go output.

Current PTM verification:
  ✅ Full line-by-line compare: trace_cov_a15.ppl (TestCompareAgainstPPL)
  ⚠️ Partial/diagnostic only: TC2.ppl (elements only, filtered/limited; PTM IDs 0x13/0x14)
  ⚠️ Not compared yet: Snowball.ppl (PTM IDs 0x10/0x11), tc2-ptm-rstk-t32.ppl

PPL generation & formats (C++):
  - decoder/tests/run_pkt_decode_tests.bash generates most decoder/tests/results/*.ppl
    * Full decode: juno-ret-stck, a57_single_step, bugfix-exact-match, juno-uname-001,
      juno-uname-002, juno_r1_1, tc2-ptm-rstk-t32, trace_cov_a15, stm_only, stm_only-2,
      stm_only-juno, stm-issue-27, TC2, Snowball, test-file-mem-offsets,
      itm_only_raw, itm_only_csformat
    * Packet monitor: init-short-addr (-pkt_mon)
    * TPIU/deformatter: a55-test-tpiu (-dstream_format, -o_raw_packed/-o_raw_unpacked)
    * Error-mode variants (same snapshot): juno_r1_1_rangelimit (OPENCSD_INSTR_RANGE_LIMIT),
      juno_r1_1_badopcode (OPENCSD_ERR_ON_AA64_BAD_OPCODE), juno_r1_1_badopcode_flag (-aa64_opcode_chk)
  - Extra outputs from test programs: c_api_test.ppl, frame_demux_test.ppl,
    mem_buff_demo.ppl/mem_buff_demo_cb.ppl, itm-decode-test.ppl
  - The first lines of each .ppl include the exact command-line and protocol/trace IDs.

Next dev: Do NOT mark PTM complete until all PTM .ppl files above are compared
line-by-line in Go tests.

TEST SNAPSHOT STRUCTURE:
------------------------
Snapshots in decoder/tests/snapshots/ contain everything needed to decode a trace:

Example: decoder/tests/snapshots/trace_cov_a15/
  snapshot.ini           - Main config (lists all devices)
  trace.ini              - Trace metadata (timestamp frequency, buffer mappings)
  device*.ini            - Device configs (register values: IDR, CTRL, CCER, etc.)
  PTM_0_2.bin            - Raw trace data (binary packet stream)
  mem_*.bin              - Memory images (code/data regions needed for instruction decode)

Loading a snapshot in Go:
  1. Parse snapshot.ini to find device configs
  2. Load device*.ini to get PTM configuration registers
  3. Read trace.ini to map trace buffers to source IDs
  4. Load PTM_*.bin as raw trace input
  5. Load mem_*.bin files for memory access during decode

See: opencsd/ptm/tc2_test.go for complete example

Key Concept - Trace Source IDs:
  - Each CoreSight trace source has a unique ID (0x00-0xFF)
  - PTM_0_2 means PTM with ID 0x02
  - ETM_1_5 means ETM with ID 0x05
  - In muxed traces, ID is used to demux packets to correct decoder
  - Frame deformatter (opencsd/frame/demux.go) splits muxed trace by ID

PPL header tip (useful for verification):
  - Each .ppl starts with the command line and "Protocol printer ..." lines listing protocol + IDs.
  - TC2.ppl is multi-protocol (ETMv3/PTM/ITM) with PTM IDs 0x13/0x14; Snowball.ppl has PTM IDs 0x10/0x11.

PROGRESS TRACKING:
-----------------

COMPLETED (Core Functionality):
1. ✓ PTM config parsing (IDR/CTRL/CCER registers) - opencsd/ptm/config.go
2. ✓ Packet processor with unsync scanning - opencsd/ptm/processor.go
3. ✓ All packet types: ASYNC, ISYNC, ATOM, BRANCH_ADDRESS, TIMESTAMP, CONTEXT_ID,
      VMID, EXCEPTION_RETURN, TRIGGER, WPOINT_UPDATE, IGNORE - opencsd/ptm/types.go
4. ✓ Decoder FSM (8 states) - opencsd/ptm/decoder.go
5. ✓ Waypoint update with TRACE_TO_ADDR_INCL/EXCL - decoder.go lines 693-721, 979-1064
6. ✓ Instruction follower: DSB/DMB waypoint handling - decoder.go lines 519-543
7. ✓ ARM and Thumb2 instruction decode - opencsd/ptm/instr_decode.go
8. ✓ Return stack for indirect branch prediction - decoder.go lines 145-149

SNAPSHOT STRUCTURE:
-------------------
Test data in decoder/tests/snapshots/{name}/:
  - snapshot.ini, trace.ini, device*.ini: Configuration (copy to decoder code)
  - PTM_X_Y.bin, mem_*.bin: Raw trace data + memory (needed for instruction decode)

Example: decoder/tests/snapshots/trace_cov_a15/
  - PTM trace ID 0x02, simple ARM execution, 9 memory regions
  - Golden output: decoder/tests/results/trace_cov_a15.ppl
  - Test loads these files and compares decoded output line-by-line

DEVELOPMENT WORKFLOW:
---------------------
1. Make code changes to opencsd/{protocol}/decoder.go
2. Run tests: go test ./{protocol} -v
3. If PPL test fails: add test.Logf() to print actual vs expected
4. Compare first 10 lines to find divergence (test output shows first mismatches)
5. Fix decoder logic to match C++ behavior exactly (consult decoder/source/{protocol}/)
6. Commit: git add -A && git commit -m "..."
7. Push: git push origin go

CRITICAL LESSONS - READ THIS:
------------------------------
These are the gotchas that caused failures during PTM port:

1. **State Machine Continuation (CRITICAL FIX)**
   - StateNoSync must emit NO_SYNC then CONTINUE (not return) to process packet
   - Without continue, ISYNC packets stall in StateWaitISYNC waiting for next packet
   - Test case: TestTC2SingleISyncDecode was failing because NO_SYNC was returned
   - Fix: Use `continue` after state transition to let FSM process same packet in new state

2. **ISYNC as First Packet (EDGE CASE)**
   - ISYNC can be the first packet (without ASYNC in test scenarios)
   - Real traces always have ASYNC first, but tests may skip it
   - StateNoSync must accept both ASYNC and ISYNC as valid sync initiators
   - Code: Check pkt.Type == PacketTypeISYNC in StateNoSync transition

3. **Timestamp Accumulation (TSUpdateBits)**
   - Timestamp packets only update if TSUpdateBits > 0
   - TSUpdateBits indicates how many bits are being updated (e.g., 48 for 48-bit timestamp)
   - Without it: mask = 0, so timestamp stays at 0
   - Test case: TestTC2LineByLine had TS=0 instead of 0x0082f9d18bcc
   - Packet creation must include TSUpdateBits field (not just Timestamp value)

4. **Output Order Matters**
   - C++ outputs elements in exact sequence - PPL files show this
   - One element out of place = test fail, even if count is correct
   - Add test logging early: t.Logf("Element: %s", printer.FormatGenericElement(elem))
   - Compare actual vs expected line-by-line (test output shows first 10 lines)

5. **Decoder d.elements Pattern**
   - ProcessPacket clears d.elements at start
   - All process*() functions append to d.elements directly AND return it
   - Do NOT re-append return values (was causing duplication in old code)
   - ProcessPacket returns d.elements at the end

ARCHITECTURE:
---------------
PTM Decoder State Machine (8 states):
  StateNoSync     → emit NO_SYNC, transition based on packet, CONTINUE
  StateWaitSync   → wait for ASYNC
  StateWaitISYNC  → wait for ISYNC (have ASYNC), process it
  StateDecodePkts → normal packet processing
  StateContISYNC, StateContAtom, StateContWaypoint, StateContBranch → unused in current impl

Key decoder files:
  opencsd/ptm/decoder.go (1071 lines)     - State machine + packet handlers
  opencsd/ptm/types.go (880 lines)        - Packet parsing
  opencsd/ptm/instr_decode.go (600 lines) - ARM/Thumb instruction decoder
  opencsd/ptm/config.go (250 lines)       - Device configuration
  opencsd/common/elements.go              - Trace element definitions

REMAINING PROTOCOLS TO PORT:
---------------------------
After PTM verification is complete, the following protocols must be ported:

PRIORITY ORDER (by usage frequency):
1. ETMv4 (~5,100 lines) - Most common modern trace protocol
   - decoder/source/etmv4/ → opencsd/etmv4/
   - Similar structure to PTM but more complex packets
   - Has timestamp, cycle count, Q elements

2. ETMv3 (~2,900 lines) - Legacy ARM trace
   - decoder/source/etmv3/ → opencsd/etmv3/
   - Simpler than ETMv4 but still widely used

3. ETE (~1,700 lines) - Embedded Trace Extension (ARMv9)
   - decoder/source/ete/ → opencsd/ete/
   - Based on ETMv4 with extensions

4. STM (~1,700 lines) - System Trace Macrocell
   - decoder/source/stm/ → opencsd/stm/
   - Software instrumentation trace

5. ITM (~1,300 lines) - Instrumentation Trace Macrocell
   - decoder/source/itm/ → opencsd/itm/
   - Cortex-M debug trace

Estimated total effort for all protocols: 4-6 weeks (assuming PTM patterns reused)

GETTING HELP:
------------
- C++ reference code is authoritative - when in doubt, match C++ behavior
- .ppl golden files show expected output format exactly
- Use opencsd/cmd/ptm_verify.go to manually inspect decoder output
- Tests in *_test.go files show how to use the decoder API

================================================================================
END OF DEVELOPER HANDOFF NOTES
================================================================================


================================================================================
APPENDIX A: C++ TO GO CODE MAPPING - PTM PROTOCOL
================================================================================

PTM Protocol Files (PORTED - verification pending):
----------------------------------------------------
C++ Source Files (decoder/source/ptm/):
  trc_pkt_decode_ptm.cpp   (24K)  → opencsd/ptm/decoder.go      (33K)
  trc_pkt_proc_ptm.cpp     (38K)  → opencsd/ptm/types.go        (22K)
  trc_pkt_elem_ptm.cpp     (12K)  → opencsd/ptm/types.go        (22K)
  trc_cmp_cfg_ptm.cpp      (2K)   → opencsd/ptm/config.go       (7K)

C++ Header Files (decoder/include/opencsd/ptm/):
  trc_pkt_decode_ptm.h     (7K)   → opencsd/ptm/decoder.go      (33K)
  trc_pkt_proc_ptm.h       (7K)   → opencsd/ptm/types.go        (22K)
  trc_pkt_elem_ptm.h       (7K)   → opencsd/ptm/types.go        (22K)
  trc_cmp_cfg_ptm.h        (7K)   → opencsd/ptm/config.go       (7K)
  trc_pkt_types_ptm.h      (6K)   → opencsd/ptm/types.go        (22K)

Additional Go Files:
  opencsd/ptm/instr_decode.go      (17K) - ARM/Thumb instruction decoder
  opencsd/ptm/processor.go         (4K)  - Packet processor wrapper
  opencsd/ptm/*_test.go            (58K) - Test suite
  opencsd/cmd/ptm_verify.go        (4K)  - Verification tool

PTM Line Count: C++ ~3,800 lines → Go ~4,500 lines (including tests)

REMAINING PROTOCOLS TO PORT (NOT STARTED):
------------------------------------------

ETMv4 Protocol (~5,100 lines):
  decoder/source/etmv4/trc_pkt_decode_etmv4i.cpp → opencsd/etmv4/decoder.go
  decoder/source/etmv4/trc_pkt_proc_etmv4i.cpp   → opencsd/etmv4/types.go
  decoder/source/etmv4/trc_pkt_elem_etmv4i.cpp   → opencsd/etmv4/types.go
  decoder/source/etmv4/trc_cmp_cfg_etmv4.cpp     → opencsd/etmv4/config.go
  + Header files in decoder/include/opencsd/etmv4/

ETMv3 Protocol (~2,900 lines):
  decoder/source/etmv3/trc_pkt_decode_etmv3.cpp  → opencsd/etmv3/decoder.go
  decoder/source/etmv3/trc_pkt_proc_etmv3.cpp    → opencsd/etmv3/types.go
  decoder/source/etmv3/trc_pkt_elem_etmv3.cpp    → opencsd/etmv3/types.go
  decoder/source/etmv3/trc_cmp_cfg_etmv3.cpp     → opencsd/etmv3/config.go
  + Header files in decoder/include/opencsd/etmv3/

ETE Protocol (~1,700 lines):
  decoder/source/ete/trc_cmp_cfg_ete.cpp         → opencsd/ete/config.go
  (ETE extends ETMv4, so will reuse much of etmv4/ implementation)

STM Protocol (~1,700 lines):
  decoder/source/stm/trc_pkt_decode_stm.cpp      → opencsd/stm/decoder.go
  decoder/source/stm/trc_pkt_proc_stm.cpp        → opencsd/stm/types.go
  decoder/source/stm/trc_pkt_elem_stm.cpp        → opencsd/stm/types.go
  decoder/source/stm/trc_cmp_cfg_stm.cpp         → opencsd/stm/config.go
  + Header files in decoder/include/opencsd/stm/

ITM Protocol (~1,300 lines):
  decoder/source/itm/trc_pkt_decode_itm.cpp      → opencsd/itm/decoder.go
  decoder/source/itm/trc_pkt_proc_itm.cpp        → opencsd/itm/types.go
  decoder/source/itm/trc_pkt_elem_itm.cpp        → opencsd/itm/types.go
  decoder/source/itm/trc_cmp_cfg_itm.cpp         → opencsd/itm/config.go
  + Header files in decoder/include/opencsd/itm/

Core Framework Components (PARTIALLY PORTED):
---------------------------------------------
Frame deformatter:
  decoder/source/trc_frame_deformatter.cpp       → ✓ opencsd/frame/demux.go

Generic elements:
  decoder/source/trc_gen_elem.cpp                → ✓ opencsd/common/elements.go

Memory accessor:
  decoder/source/mem_acc/*.cpp                   → ✓ opencsd/common/mem_*.go

Decode tree (NOT PORTED):
  decoder/source/ocsd_dcd_tree.cpp               → opencsd/tree/ (TBD)

Code follower (NOT PORTED):
  decoder/source/ocsd_code_follower.cpp          → opencsd/common/ (TBD)

Return stack:
  decoder/source/trc_ret_stack.cpp               → ✓ in opencsd/ptm/decoder.go

Error handling:
  decoder/source/ocsd_error*.cpp                 → PARTIAL in opencsd/common/logger.go

Instruction decoder:
  decoder/source/i_dec/*.cpp                     → ✓ opencsd/ptm/instr_decode.go (ARM/Thumb only)
  (Will need extension for A64, RISC-V when porting ETMv4/ETE)

Packet printers:
  decoder/source/pkt_printers/*.cpp              → ✓ opencsd/printer/printer.go

PORTING STRATEGY FOR REMAINING PROTOCOLS:
-----------------------------------------
1. Use PTM as template - same packet/decoder/config structure
2. Each protocol gets its own directory: opencsd/{etmv4,etmv3,ete,stm,itm}/
3. Reuse common infrastructure: frame demux, memory accessor, elements
4. Create protocol-specific tests using decoder/tests/snapshots-ete/ etc.
5. Generate .ppl golden files from C++ for each protocol
6. Verify with TestCompareAgainstPPL pattern established for PTM

================================================================================
APPENDIX B: QUICK START FOR NEW DEVELOPER - PTM VERIFICATION
================================================================================

GOAL: Complete PTM verification to 100%, then start next protocol port

1. CLONE AND SETUP
   git clone https://github.com/awmorgan/OpenCSD
   cd OpenCSD
   git checkout go
   cd opencsd

2. VERIFY ENVIRONMENT
   go version  # Should be 1.19 or later
   go test ./ptm -v -run TestDecoder  # Basic decoder test

3. UNDERSTAND THE GOLDEN FILES
   cd ../decoder/tests/results
   head -50 trace_cov_a15.ppl  # See expected output format
   
   Format of .ppl files:
   - Idx: Packet/element sequence number
   - ID: Trace source ID (0x00 for PTM in most tests)
   - Packet lines: [0x08 0x01...] ISYNC (etc.)
   - Element lines: OCSD_GEN_TRC_ELEM_TRACE_ON; (etc.)

4. RUN VERIFICATION TEST
   cd ../../../opencsd
   go test ./ptm -v -run TestCompareAgainstPPL
   # This verifies trace_cov_a15 only. Expand coverage to remaining PTM .ppl files.
   
================================================================================
NEXT STEPS FOR NEXT DEVELOPER:
================================================================================

PTM verification is incomplete. Next: finish PTM .ppl comparisons before porting other protocols.

For ETMv4 (most important):
1. mkdir opencsd/etmv4
2. Copy PTM structure: config.go, types.go, decoder.go, processor.go, instr_decode.go
3. Study C++ reference: decoder/source/etmv4/trc_pkt_decode_etmv4i.cpp
4. Generate golden files: decoder/tests/results/*.ppl (build C++ first)
5. Port packet parsing (types.go), then decoder FSM (decoder.go)
6. Use TestCompareAgainstPPL pattern - same as PTM
7. Test incrementally: start trace_cov_a15, then larger snapshots
8. Estimated: 2-3 weeks

For other protocols (ETMv3, ETE, STM, ITM):
- Same approach, 1-2 weeks each
- Total effort: 6-8 weeks for all

================================================================================
APPENDIX: C++ TO GO FILE MAPPING - PTM
================================================================================

PTM Files (PORTED - verification pending):
  trc_pkt_decode_ptm.cpp      → opencsd/ptm/decoder.go
  trc_pkt_proc_ptm.cpp        → opencsd/ptm/types.go
  trc_cmp_cfg_ptm.cpp         → opencsd/ptm/config.go
  (+ supporting files above)

Line counts: C++ ~3,800 lines → Go ~4,500 lines (including tests + comments)

================================================================================
APPENDIX: VERIFICATION CHECKLIST
================================================================================

Before marking protocol complete, ensure:

PTM Verification (2026-02-01):
  □ Full line-by-line compare for trace_cov_a15.ppl
  □ Full line-by-line compare for Snowball.ppl (PTM IDs 0x10/0x11)
  □ Full line-by-line compare for tc2-ptm-rstk-t32.ppl
  □ Full line-by-line compare for TC2.ppl (PTM IDs 0x13/0x14)
  □ TC2 tests validated without filtering (ADDR_NACC, line counts, etc.)

For future protocols:
  □ TestCompareAgainstPPL passes 100%
  □ All .ppl files in decoder/tests/results/ verify
  □ All snapshots in decoder/tests/snapshots/ decode correctly
  □ Memory access errors handled (ADDR_NACC elements correct)
  □ Context/VMID changes handled
  □ Exception handling matches C++
  □ ISA switching works (ARM/Thumb/A64 if applicable)
  □ Instruction attributes formatted correctly
  □ Timestamp accumulation verified
  □ Return stack prediction works (if protocol supports it)

================================================================================
END OF NOTES

