================================================================================
OpenCSD Go Port - Developer Handoff Notes (2026-01-31)
================================================================================

PROJECT: Go port of ARM's CoreSight trace decoder library (OpenCSD).
Scope: ~22,400 lines of C++ → Go across 6 trace protocols + framework.

STATUS (2026-01-31):
  PTM protocol: ✅ MOSTLY COMPLETE (parity gaps remain – see TESTING GAPS)
  ETMv4: ⚠️ IN PROGRESS (config parser complete)
  ETMv3, ETE, STM, ITM: ⚠️ NOT STARTED
  Framework: PARTIAL (memory accessor, frame demux, printer done)

QUICK START:
  git clone https://github.com/awmorgan/OpenCSD && cd OpenCSD && git checkout go
  cd opencsd && go test ./...                        # Run all tests

KEY LOCATIONS:
  Go code: opencsd/
  C++ reference: decoder/source/ and decoder/include/
  Test data: decoder/tests/snapshots/ (contains memory + device configs)
  Golden files: decoder/tests/results/*.ppl (authoritative reference)

GIT REPOSITORY & BRANCHES:
--------------------------
Repository: https://github.com/awmorgan/OpenCSD
Active Branch: go
Main C++ Code: main branch (decoder/ directory)
Go Port Location: go branch (opencsd/ directory)

Setup:
  git clone https://github.com/awmorgan/OpenCSD
  cd OpenCSD
  git checkout go

Go Module:
  module opencsd
  go 1.25.6
  No external dependencies (pure Go implementation)

VERIFICATION & TESTING:
-----------------------
Golden files (.ppl) are the authoritative reference for verifying decoder output.

PTM protocol verified against all 4 PTM-containing .ppl files:
  - trace_cov_a15.ppl (single PTM, ID 0x02)
  - tc2-ptm-rstk-t32.ppl (single PTM with return stack)
  - Snowball.ppl (multi-protocol: PTM IDs 0x10/0x11)
  - TC2.ppl (multi-protocol: PTM IDs 0x13/0x14, ETMv3, ITM)

PPL generation & formats (C++):
  - decoder/tests/run_pkt_decode_tests.bash generates most decoder/tests/results/*.ppl
    * Full decode: juno-ret-stck, a57_single_step, bugfix-exact-match, juno-uname-001,
      juno-uname-002, juno_r1_1, tc2-ptm-rstk-t32, trace_cov_a15, stm_only, stm_only-2,
      stm_only-juno, stm-issue-27, TC2, Snowball, test-file-mem-offsets,
      itm_only_raw, itm_only_csformat
    * Packet monitor: init-short-addr (-pkt_mon)
    * TPIU/deformatter: a55-test-tpiu (-dstream_format, -o_raw_packed/-o_raw_unpacked)
    * Error-mode variants (same snapshot): juno_r1_1_rangelimit (OPENCSD_INSTR_RANGE_LIMIT),
      juno_r1_1_badopcode (OPENCSD_ERR_ON_AA64_BAD_OPCODE), juno_r1_1_badopcode_flag (-aa64_opcode_chk)
  - Extra outputs from test programs: c_api_test.ppl, frame_demux_test.ppl,
    mem_buff_demo.ppl/mem_buff_demo_cb.ppl, itm-decode-test.ppl
  - The first lines of each .ppl include the exact command-line and protocol/trace IDs.

Next dev: Continue ETMv4 port - packet types and decoder next.

TEST SNAPSHOT STRUCTURE:
------------------------
Snapshots in decoder/tests/snapshots/ contain everything needed to decode a trace:

Example: decoder/tests/snapshots/trace_cov_a15/
  snapshot.ini           - Main config (lists all devices)
  trace.ini              - Trace metadata (timestamp frequency, buffer mappings)
  device*.ini            - Device configs (register values: IDR, CTRL, CCER, etc.)
  PTM_0_2.bin            - Raw trace data (binary packet stream)
  mem_*.bin              - Memory images (code/data regions needed for instruction decode)

Loading a snapshot in Go:
  1. Parse snapshot.ini to find device configs
  2. Load device*.ini to get PTM configuration registers
  3. Read trace.ini to map trace buffers to source IDs
  4. Load PTM_*.bin as raw trace input
  5. Load mem_*.bin files for memory access during decode

See: opencsd/ptm/tc2_test.go for complete example

Key Concept - Trace Source IDs:
  - Each CoreSight trace source has a unique ID (0x00-0xFF)
  - PTM_0_2 means PTM with ID 0x02
  - ETM_1_5 means ETM with ID 0x05
  - In muxed traces, ID is used to demux packets to correct decoder
  - Frame deformatter (opencsd/frame/demux.go) splits muxed trace by ID

PPL header tip (useful for verification):
  - Each .ppl starts with the command line and "Protocol printer ..." lines listing protocol + IDs.
  - TC2.ppl is multi-protocol (ETMv3/PTM/ITM) with PTM IDs 0x13/0x14; Snowball.ppl has PTM IDs 0x10/0x11.

PROGRESS TRACKING:
-----------------

PTM Protocol (MOSTLY COMPLETE):
  - Config parsing: IDR/CTRL/CCER registers
  - Packet processor with unsync scanning
  - All packet types (ASYNC, ISYNC, ATOM, BRANCH_ADDRESS, TIMESTAMP, CONTEXT_ID, VMID, EXCEPTION_RETURN, TRIGGER, WPOINT_UPDATE, IGNORE)
  - Decoder FSM with 8 states
  - Waypoint update handling (TRACE_TO_ADDR_INCL/EXCL)
  - ARM/Thumb instruction decode with DSB/DMB/ISB barrier handling
  - Return stack for indirect branch prediction
  - Line-by-line .ppl verification (trace_cov_a15, tc2-ptm-rstk-t32, Snowball, TC2)
  - NOTE: PTM test suite currently filters or skips some outputs (e.g., ADDR_NACC)
    and does not yet cover all C++ decoder modes or error paths.

TESTING GAPS (PTM):
-------------------
These explain how PTM can appear “complete” while missing functionality:

1) **Snapshot-only coverage**
   - Current Go tests compare against a subset of .ppl outputs and only for
     certain trace IDs.
   - Some tests compare just the first N lines or filter out ADDR_NACC lines.
     This can hide real mismatches in memory-access handling.

2) **Missing C++ execution modes**
   - No Go tests cover C++ `-pkt_mon` output, raw packet printing, or
     deformatter/dstream format outputs.
   - Error-mode variants from C++ (range limits, bad opcode flags, etc.) are
     not mirrored in Go tests.

3) **Streaming / chunked input not tested**
   - Go tests parse full buffers in one shot. C++ supports streaming with
     partial packets, flush, and EOT handling. This can hide state machine and
     resync bugs.

4) **Config and register-variant coverage is thin**
   - Context-ID width, VMID enable, timestamp encoding (binary/Gray), 64‑bit
     timestamps, and cycle-accurate tracing are not tested across multiple
     register combinations.

5) **Loss-of-sync & invalid packet paths**
   - Go tests rarely exercise BAD/RESERVED packet handling, unsync buffers, or
     explicit NO_SYNC/EO_TRACE paths from stream errors.

Suggested next tests:
  - Add packet-level parity tests against C++ “packet monitor” output.
  - Add stream-chunking tests (varying block sizes, random splits) to exercise
    partial packets + flush + EOT.
  - Add C++ error-mode snapshot tests (range limit, bad opcode flags) and verify
    matching element output.
  - Stop filtering ADDR_NACC in TC2 tests; instead fix NACC logic to match C++.

ETMv4 Protocol (IN PROGRESS):
  - Config parsing: TRCIDR0-13, TRCCONFIGR, TRCTRACEIDR registers (COMPLETE)
  - Register helper methods mirroring C++ EtmV4Config class (COMPLETE)
  - Packet types: NOT STARTED
  - Packet processor: NOT STARTED
  - Decoder FSM: NOT STARTED

Framework Components:
  - Snapshot.ini parser (ARM spec v0.2 compliant)
  - Frame demultiplexer (muxed trace support)
  - Memory accessor (binary file + callback)
  - Packet printer (generic elements)
  - Instruction decoder (ARM/Thumb only - A64 needed for ETMv4)

SNAPSHOT STRUCTURE:
-------------------
Test data in decoder/tests/snapshots/{name}/:
  - snapshot.ini, trace.ini, device*.ini: Configuration (copy to decoder code)
  - PTM_X_Y.bin, mem_*.bin: Raw trace data + memory (needed for instruction decode)

Example: decoder/tests/snapshots/trace_cov_a15/
  - PTM trace ID 0x02, simple ARM execution, 9 memory regions
  - Golden output: decoder/tests/results/trace_cov_a15.ppl
  - Test loads these files and compares decoded output line-by-line

DEVELOPMENT WORKFLOW:
---------------------
1. Make code changes to opencsd/{protocol}/decoder.go
2. Run tests: go test ./{protocol} -v
3. If PPL test fails: add test.Logf() to print actual vs expected
4. Compare first 10 lines to find divergence (test output shows first mismatches)
5. Fix decoder logic to match C++ behavior exactly (consult decoder/source/{protocol}/)
   - For investigation, create small Go debug programs under opencsd/cmd/debug_xxx/
     (e.g., cmd/debug_snowball, cmd/debug_branchaddr). Use Go only (no Python).
     These should load snapshots, run demux/parse/decoder, and print diagnostics.
6. Commit: git add -A && git commit -m "..."
7. Push: git push origin go

CURRENT BLOCKER:
----------------
ETMv4 packet types need to be ported from C++ trc_pkt_types_etmv4.h next.

SESSION UPDATES (2026-01-31):
-----------------------------
ETMv4 config parser implemented:
  - Added opencsd/etmv4/config.go with LoadConfig(), FindDeviceIniByTraceID()
  - Implemented all register helpers mirroring C++ EtmV4Config class
  - Added config_test.go using juno-ret-stck snapshot
  - Tests passing: go test ./etmv4

PTM protocol marked complete:
  - All 4 PTM-containing .ppl files verified line-by-line
  - Snapshot parser updated to ARM spec v0.2 with version validation
  - All Go tests passing (go test ./...)

Debug helpers (Go only):
  - opencsd/cmd/debug_snowball
  - opencsd/cmd/debug_branchaddr
  - opencsd/cmd/debug_instr
  - opencsd/cmd/debug_tc2

ADDITIONAL NOTES (WHAT WOULD HAVE HELPED):
------------------------------------------
- TC2.ppl includes PTM ID 0x14 but only EO_TRACE (no packets). The demuxer
  may return no data for that ID; the compare test should still pass by
  emitting only EO_TRACE for ID 0x14.
- For instruction-level debugging, prefer Go helpers under opencsd/cmd/debug_*.
  Example: run `go run ./cmd/debug_tc2 -start 0xC000CD4E -end 0xC000CDA0`.
- For Thumb2 decode, do not return early on invalid conditional-branch patterns;
  allow other instruction forms to match later in decode.

CRITICAL LESSONS - READ THIS:
------------------------------
These are the gotchas that caused failures during PTM port:

1. **State Machine Continuation (CRITICAL FIX)**
   - StateNoSync must emit NO_SYNC then CONTINUE (not return) to process packet
   - Without continue, ISYNC packets stall in StateWaitISYNC waiting for next packet
   - Test case: TestTC2SingleISyncDecode was failing because NO_SYNC was returned
   - Fix: Use `continue` after state transition to let FSM process same packet in new state

2. **ISYNC as First Packet (EDGE CASE)**
   - ISYNC can be the first packet (without ASYNC in test scenarios)
   - Real traces always have ASYNC first, but tests may skip it
   - StateNoSync must accept both ASYNC and ISYNC as valid sync initiators
   - Code: Check pkt.Type == PacketTypeISYNC in StateNoSync transition

3. **Timestamp Accumulation (TSUpdateBits)**
   - Timestamp packets only update if TSUpdateBits > 0
   - TSUpdateBits indicates how many bits are being updated (e.g., 48 for 48-bit timestamp)
   - Without it: mask = 0, so timestamp stays at 0
   - Test case: TestTC2LineByLine had TS=0 instead of 0x0082f9d18bcc
   - Packet creation must include TSUpdateBits field (not just Timestamp value)

4. **Output Order Matters**
   - C++ outputs elements in exact sequence - PPL files show this
   - One element out of place = test fail, even if count is correct
   - Add test logging early: t.Logf("Element: %s", printer.FormatGenericElement(elem))
   - Compare actual vs expected line-by-line (test output shows first 10 lines)

5. **Decoder d.elements Pattern**
   - ProcessPacket clears d.elements at start
   - All process*() functions append to d.elements directly AND return it
   - Do NOT re-append return values (was causing duplication in old code)
   - ProcessPacket returns d.elements at the end

ARCHITECTURE:
---------------
PTM Decoder State Machine (8 states):
  StateNoSync     → emit NO_SYNC, transition based on packet, CONTINUE
  StateWaitSync   → wait for ASYNC
  StateWaitISYNC  → wait for ISYNC (have ASYNC), process it
  StateDecodePkts → normal packet processing
  StateContISYNC, StateContAtom, StateContWaypoint, StateContBranch → unused in current impl

Key decoder files:
  opencsd/ptm/decoder.go (1071 lines)     - State machine + packet handlers
  opencsd/ptm/types.go (880 lines)        - Packet parsing
  opencsd/ptm/instr_decode.go (600 lines) - ARM/Thumb instruction decoder
  opencsd/ptm/config.go (250 lines)       - Device configuration
  opencsd/common/elements.go              - Trace element definitions

REMAINING PROTOCOLS TO PORT:
---------------------------
ETMv4 (~5,100 lines) - IN PROGRESS
   - Config parser: COMPLETE
   - Packet types: NOT STARTED
   - Packet processor: NOT STARTED
   - Decoder FSM: NOT STARTED

ETMv3 (~2,900 lines) - NOT STARTED

ETE (~1,700 lines) - NOT STARTED

STM (~1,700 lines) - NOT STARTED

ITM (~1,300 lines) - NOT STARTED

GETTING HELP:
------------
- C++ reference code is authoritative - when in doubt, match C++ behavior
- .ppl golden files show expected output format exactly
- Use opencsd/cmd/ptm_verify.go to manually inspect decoder output
- Tests in *_test.go files show how to use the decoder API

================================================================================
END OF DEVELOPER HANDOFF NOTES
================================================================================


================================================================================
APPENDIX A: C++ TO GO CODE MAPPING
================================================================================

PTM Protocol (COMPLETE):
  decoder/source/ptm/trc_pkt_decode_ptm.cpp   → opencsd/ptm/decoder.go
  decoder/source/ptm/trc_pkt_proc_ptm.cpp     → opencsd/ptm/types.go
  decoder/source/ptm/trc_cmp_cfg_ptm.cpp      → opencsd/ptm/config.go
  + instruction decoder: opencsd/ptm/instr_decode.go

ETMv4 Protocol (IN PROGRESS):
  decoder/source/etmv4/trc_cmp_cfg_etmv4.cpp  → opencsd/etmv4/config.go (COMPLETE)
  decoder/source/etmv4/trc_pkt_proc_etmv4i.cpp → opencsd/etmv4/types.go (NOT STARTED)
  decoder/source/etmv4/trc_pkt_decode_etmv4i.cpp → opencsd/etmv4/decoder.go (NOT STARTED)

Framework Components:
  decoder/source/trc_frame_deformatter.cpp    → opencsd/frame/demux.go (COMPLETE)
  decoder/source/trc_gen_elem.cpp             → opencsd/common/elements.go (COMPLETE)
  decoder/source/mem_acc/*.cpp                → opencsd/common/mem_*.go (COMPLETE)
  decoder/source/pkt_printers/*.cpp           → opencsd/printer/printer.go (COMPLETE)

================================================================================
APPENDIX B: NEXT STEPS - ETMv4 PORT
================================================================================

Current state: ETMv4 config parser complete, tested, passing.

Next tasks:
1. Port ETMv4 packet types from decoder/include/opencsd/etmv4/trc_pkt_types_etmv4.h
   - Create opencsd/etmv4/types.go
   - Define packet type enums and structures
   
2. Port ETMv4 packet processor from decoder/source/etmv4/trc_pkt_proc_etmv4i*.cpp
   - Implement packet parsing and boundary detection
   - Handle sync patterns and alignment
   
3. Port ETMv4 decoder from decoder/source/etmv4/trc_pkt_decode_etmv4i*.cpp
   - Implement instruction trace decoder state machine
   - Add A64 instruction decoder (ETMv4 requires AArch64 support)
   
4. Create ETMv4 tests using juno-ret-stck and other ETMv4 snapshots
   - Line-by-line .ppl comparison like PTM
   
Expected effort: 2-3 weeks based on PTM experience.

================================================================================
APPENDIX: C++ TO GO FILE MAPPING - PTM

================================================================================
APPENDIX: VERIFICATION CHECKLIST

================================================================================
END OF NOTES

