package ptm_test

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"testing"

	"opencsd/common"
	"opencsd/printer"
	"opencsd/ptm"
	"opencsd/tests/helpers"
)

const snapshotPath = "../../decoder/tests/snapshots/trace_cov_a15"

func TestCompareAgainstPPL(t *testing.T) {
	// TODO: Remove skip once PTM instruction follower matches C++ parity.
	// t.Skip("PTM instruction follower not yet implemented; PPL parity test pending")
	// Setup paths
	pplPath := "../../decoder/tests/results/trace_cov_a15.ppl"
	
	// Skip if PPL file doesn't exist (needs to be generated by C++ decoder first)
	if _, err := os.Stat(pplPath); os.IsNotExist(err) {
		t.Skip("PPL reference file not found. Run regen_ppl_outputs.bash to generate it.")
	}
	binPath := filepath.Join(snapshotPath, "PTM_0_2.bin")
	traceIniPath := filepath.Join(snapshotPath, "trace.ini")

	packetID, elemID, err := parseTraceIDs(traceIniPath)
	if err != nil {
		t.Fatalf("Failed to parse trace IDs: %v", err)
	}

	// Load expected records (packets + elements)
	expectedRecords, err := helpers.LoadPPLRecords(pplPath)
	if err != nil {
		t.Fatalf("Failed to load PPL file: %v", err)
	}

	// Setup decoder
	memAcc := loadMemorySnapshot(t)
	decoder := ptm.NewDecoder(packetID)
	decoder.RetStackEnable = true
	decoder.SetMemoryAccessor(memAcc)

	// Load trace data
	raw, err := os.ReadFile(binPath)
	if err != nil {
		t.Fatalf("Failed to read binary trace: %v", err)
	}

	// Parse all packets
	packets, err := decoder.Parse(raw)
	if err != nil {
		t.Fatalf("Parse error: %v", err)
	}

	// Generate actual output lines (packets + elements), interleaved
	var actualLines []string
	prevISA := common.ISAARM
	prevISAValid := false
	lastPacketAddr := uint64(0)
	for _, pkt := range packets {
		pktForPrint := pkt
		if pkt.Type == ptm.PacketTypeBranchAddr && pkt.ISAValid && prevISAValid && pkt.ISA == prevISA {
			pktForPrint.ISAValid = false
		}
		if pkt.Type == ptm.PacketTypeBranchAddr && pkt.AddrBits > 0 {
			mask := (uint64(1) << pkt.AddrBits) - 1
			pktForPrint.Address = (lastPacketAddr & ^mask) | (pktForPrint.Address & mask)
		}
		actualLines = append(actualLines, printer.FormatRawPacketLine(pkt.Offset, packetID, pktForPrint))
		elems, err := decoder.ProcessPacket(pkt)
		if err != nil {
			t.Logf("ProcessPacket error: %v", err)
		}
		for _, elem := range elems {
			actualLines = append(actualLines, printer.FormatGenericElementLine(pkt.Offset, elemID, elem))
		}

		if pkt.Type == ptm.PacketTypeISYNC {
			prevISA = pkt.ISA
			prevISAValid = true
			lastPacketAddr = pkt.Address
		} else if pkt.Type == ptm.PacketTypeBranchAddr && pkt.ISAValid {
			prevISA = pkt.ISA
			prevISAValid = true
			lastPacketAddr = pktForPrint.Address
		} else if pkt.Type == ptm.PacketTypeBranchAddr {
			lastPacketAddr = pktForPrint.Address
		}
	}

	if len(packets) > 0 {
		eotElem := common.GenericTraceElement{Type: common.ElemTypeEOTrace}
		lastOffset := packets[len(packets)-1].Offset
		actualLines = append(actualLines, printer.FormatGenericElementLine(lastOffset, elemID, eotElem))
	}

	// Filter expected records by trace IDs we use for packet/element streams
	packetIDStr := fmt.Sprintf("%x", packetID)
	elemIDStr := fmt.Sprintf("%x", elemID)
	var expectedLines []string
	for _, rec := range expectedRecords {
		idLower := strings.ToLower(rec.ID)
		switch rec.Kind {
		case helpers.PPLRecordPacket:
			if idLower == packetIDStr {
				expectedLines = append(expectedLines, rec.Line)
			}
		case helpers.PPLRecordElement:
			if idLower == elemIDStr {
				expectedLines = append(expectedLines, rec.Line)
			}
		}
	}

	minLen := len(expectedLines)
	if len(actualLines) < minLen {
		minLen = len(actualLines)
	}

	for i := 0; i < minLen; i++ {
		if actualLines[i] != expectedLines[i] {
			t.Fatalf("Mismatch at line %d:\nExpected: %s\nActual:   %s", i, expectedLines[i], actualLines[i])
		}
	}

	if len(actualLines) != len(expectedLines) {
		if len(actualLines) < len(expectedLines) {
			t.Fatalf("Line count mismatch: expected %d, got %d. First missing expected line: %s", len(expectedLines), len(actualLines), expectedLines[minLen])
		}
		t.Fatalf("Line count mismatch: expected %d, got %d. First extra actual line: %s", len(expectedLines), len(actualLines), actualLines[minLen])
	}
}

func loadMemorySnapshot(t *testing.T) common.MemoryAccessor {
	t.Helper()

	memMap := common.NewMultiRegionMemory()

	regions := []struct {
		addr uint64
		file string
	}{
		{0x80000000, "mem_Cortex-A15_0_0_VECTORS.bin"},
		{0x80000278, "mem_Cortex-A15_0_1_RO_CODE.bin"},
		{0x80001C28, "mem_Cortex-A15_0_2_RO_DATA.bin"},
		{0x80001D58, "mem_Cortex-A15_0_3_RW_DATA.bin"},
		{0x80001D68, "mem_Cortex-A15_0_4_ZI_DATA.bin"},
		{0x80040000, "mem_Cortex-A15_0_5_ARM_LIB_HEAP.bin"},
		{0x80080000, "mem_Cortex-A15_0_6_ARM_LIB_STACK.bin"},
		{0x80090000, "mem_Cortex-A15_0_7_IRQ_STACK.bin"},
		{0x80100000, "mem_Cortex-A15_0_8_TTB.bin"},
	}

	for _, region := range regions {
		path := filepath.Join(snapshotPath, region.file)
		data, err := os.ReadFile(path)
		if err != nil {
			t.Fatalf("Failed to load memory region %s: %v", region.file, err)
		}
		memMap.AddRegion(common.NewMemoryBuffer(region.addr, data))
	}

	return memMap
}

func parseTraceIDs(traceIniPath string) (uint8, uint8, error) {
	file, err := os.Open(traceIniPath)
	if err != nil {
		return 0, 0, err
	}
	defer file.Close()

	nameRe := regexp.MustCompile(`(?i)^name=([a-z]+)_(\d+)_(\d+)`)
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if matches := nameRe.FindStringSubmatch(line); len(matches) == 4 {
			// packetID and elemID should both be the trace ID (matches[3])
			// matches[2] is the stream index/buffer index, not the trace ID
			id, err := parseUint8(matches[3])
			if err != nil {
				return 0, 0, err
			}
			return id, id, nil
		}
	}

	if err := scanner.Err(); err != nil {
		return 0, 0, err
	}

	return 0, 0, fmt.Errorf("trace IDs not found in %s", traceIniPath)
}

func parseUint8(val string) (uint8, error) {
	parsed, err := strconv.ParseUint(val, 10, 8)
	if err != nil {
		return 0, fmt.Errorf("invalid uint8: %s", val)
	}
	return uint8(parsed), nil
}
