package dcdtree

import (
	"opencsd/internal/common"
	"opencsd/internal/demux"
	"opencsd/internal/interfaces"
	"opencsd/internal/memacc"
	"opencsd/internal/ocsd"
)

// DecodeTree manages the decoding of trace data from a single trace sink.
type DecodeTree struct {
	treeType         ocsd.DcdTreeSrc
	frameDeformatter *demux.FrameDeformatter
	decodeElements   map[uint8]*DecodeTreeElement

	defaultMapper memacc.Mapper
	createdMapper bool

	iDecoderRoot interfaces.TrcDataIn
	iInstrDecode common.InstrDecode
	iMemAccess   common.TargetMemAccess
	iGenElemOut  interfaces.TrcGenElemIn

	demuxStats ocsd.DemuxStats
}

// CreateDecodeTree creates a new Trace Decode Tree.
func CreateDecodeTree(srcType ocsd.DcdTreeSrc, formatterCfgFlags uint32) *DecodeTree {
	dt := &DecodeTree{
		treeType:       srcType,
		decodeElements: make(map[uint8]*DecodeTreeElement),
	}

	if srcType == ocsd.TrcSrcFrameFormatted {
		dt.frameDeformatter = demux.NewFrameDeformatter()
		dt.frameDeformatter.Configure(formatterCfgFlags)
		dt.iDecoderRoot = dt.frameDeformatter
	}

	return dt
}

// Destroy cleans up memory accessors (although GC does mostly).
func (dt *DecodeTree) Destroy() {
	dt.decodeElements = nil
	dt.frameDeformatter = nil
	if dt.createdMapper && dt.defaultMapper != nil {
		dt.defaultMapper = nil
	}
}

// TraceDataIn handles incoming raw byte trace streams into the tree.
func (dt *DecodeTree) TraceDataIn(op ocsd.DatapathOp, index ocsd.TrcIndex, data []byte) (uint32, ocsd.DatapathResp) {
	if dt.iDecoderRoot != nil {
		amt, resp := dt.iDecoderRoot.TraceDataIn(op, index, data)
		return amt, resp
	}

	// Unformatted single trace source fallback
	if dt.treeType == ocsd.TrcSrcSingle {
		for _, elem := range dt.decodeElements {
			if elem.DataIn != nil {
				amt, resp := elem.DataIn.TraceDataIn(op, index, data)
				return amt, resp
			}
		}
	}
	return 0, ocsd.RespFatalNotInit
}

// CreateDecoder creates a trace processor within the tree for a generic trace config.
func (dt *DecodeTree) CreateDecoder(decoderName string, createFlags int, config any) ocsd.Err {
	mngr, err := GetDecoderRegister().GetDecoderMngrByName(decoderName)
	if err != ocsd.OK {
		return err
	}

	type configWithID interface {
		TraceID() uint8
	}
	cfgID, ok := config.(configWithID)
	if !ok {
		return ocsd.ErrInvalidParamType
	}
	csID := cfgID.TraceID()

	if _, exists := dt.decodeElements[csID]; exists {
		return ocsd.ErrAttachTooMany
	}

	var pktIn interfaces.TrcDataIn
	var handle any

	if (createFlags & ocsd.CreateFlgFullDecoder) != 0 {
		var err2 ocsd.Err
		pktIn, handle, err2 = mngr.CreateDecoder(int(csID), config)
		if err2 != ocsd.OK {
			return err2
		}
	} else if (createFlags & ocsd.CreateFlgPacketProc) != 0 {
		h := mngr.CreatePktProc(int(csID), config)
		if h == nil {
			return ocsd.ErrInvalidParamType
		}
		handle = h
		if in, ok := h.(interfaces.TrcDataIn); ok {
			pktIn = in
		}
	}

	if handle == nil {
		return ocsd.ErrFail
	}

	elem := NewDecodeTreeElement(decoderName, mngr, handle, pktIn, true)
	dt.decodeElements[csID] = elem

	if dt.frameDeformatter != nil && pktIn != nil {
		dt.frameDeformatter.SetIDStream(csID, pktIn)
	}

	// Try auto-wire interfaces
	if comp, ok := handle.(interface {
		GetTraceElemOutAttachPt() *common.AttachPt[interfaces.TrcGenElemIn]
	}); ok && dt.iGenElemOut != nil {
		comp.GetTraceElemOutAttachPt().ReplaceFirst(dt.iGenElemOut)
	}

	if comp, ok := handle.(interface {
		GetInstrDecodeAttachPt() *common.AttachPt[common.InstrDecode]
	}); ok && dt.iInstrDecode != nil {
		comp.GetInstrDecodeAttachPt().ReplaceFirst(dt.iInstrDecode)
	}

	if comp, ok := handle.(interface {
		GetMemAccAttachPt() *common.AttachPt[common.TargetMemAccess]
	}); ok && dt.iMemAccess != nil {
		comp.GetMemAccAttachPt().ReplaceFirst(dt.iMemAccess)
	}

	return ocsd.OK
}

// RemoveDecoder removes a decoder mapped to the given CSID.
func (dt *DecodeTree) RemoveDecoder(csID uint8) {
	if dt.frameDeformatter != nil {
		dt.frameDeformatter.SetIDStream(csID, nil)
	}
	delete(dt.decodeElements, csID)
}

// SetGenTraceElemOutI attaches a sink for generic trace element outputs generated by the entire tree.
func (dt *DecodeTree) SetGenTraceElemOutI(outI interfaces.TrcGenElemIn) {
	dt.iGenElemOut = outI
	for _, elem := range dt.decodeElements {
		if comp, ok := elem.DecoderHandle.(interface {
			GetTraceElemOutAttachPt() *common.AttachPt[interfaces.TrcGenElemIn]
		}); ok {
			comp.GetTraceElemOutAttachPt().ReplaceFirst(outI)
		}
	}
}

// SetInstrDecoder attaches the instruction decoder for code-following decoders in the tree.
func (dt *DecodeTree) SetInstrDecoder(instrDec common.InstrDecode) {
	dt.iInstrDecode = instrDec
	for _, elem := range dt.decodeElements {
		if comp, ok := elem.DecoderHandle.(interface {
			GetInstrDecodeAttachPt() *common.AttachPt[common.InstrDecode]
		}); ok {
			comp.GetInstrDecodeAttachPt().ReplaceFirst(instrDec)
		}
	}
}

// SetMemAccessI attaches the memory accessor interface for instruction decoding.
func (dt *DecodeTree) SetMemAccessI(memI common.TargetMemAccess) {
	dt.iMemAccess = memI
	for _, elem := range dt.decodeElements {
		if comp, ok := elem.DecoderHandle.(interface {
			GetMemAccAttachPt() *common.AttachPt[common.TargetMemAccess]
		}); ok {
			comp.GetMemAccAttachPt().ReplaceFirst(memI)
		}
	}
}

// GetFrameDeformatter returns the active frame demux.
func (dt *DecodeTree) GetFrameDeformatter() *demux.FrameDeformatter {
	return dt.frameDeformatter
}

// GetFirstElement provides iteration entry point.
func (dt *DecodeTree) GetFirstElement() (uint8, *DecodeTreeElement) {
	for k, v := range dt.decodeElements {
		return k, v
	}
	return 0, nil
}
